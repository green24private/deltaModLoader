<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DELTARUNEWeb Mod Loader!</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="icon" type="x-icon" href="patch.png">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" />
    <style>
        @font-face {
            font-family: "Determination";
            src: url("8bitOperatorPlus-Bold.ttf") format("truetype");
            font-weight: normal;
            font-style: normal;
        }

        body {
            font-family: "Determination", sans-serif;
        }

        .drag-over {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }
    </style>
</head>

<body class="bg-gray-100 dark:bg-gray-900 flex items-center justify-center min-h-screen">
    <div class="w-full max-w-lg mx-auto bg-white dark:bg-gray-800 rounded-2xl shadow-2xl p-8 transition-all duration-300">
        <div class="text-center">
            <img src="patch.png" class="mx-auto h-12 w-12" />
            <h1 class="text-2xl font-bold text-gray-800 dark:text-white mt-4">
                DELTARUNEWeb Mod Loader!
            </h1>
            <p class="text-gray-500 dark:text-gray-400 mt-2">
                Select your modâ€™s required version, chapter, and upload your .xdelta
                patch.
            </p>
        </div>

        <form id="patchForm" class="mt-6 space-y-4">
            <div>
                <label for="version" style="margin-bottom: 7px" class="block text-gray-700 dark:text-gray-300 font-medium">Select your mod's required version:</label>
                <select id="version" required class="w-full border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white p-2 focus:ring-2 focus:ring-blue-500">
                    <option value="1.00">1.00</option>
                    <option value="1.01A">1.01A</option>
                    <option value="1.01B">1.01B</option>
                    <option value="1.01C">1.01C</option>
                    <option value="1.02">1.02</option>
                    <option value="1.03">1.03</option>
                    <option value="1.04" selected>1.04</option>
                    <option value="1.05">1.05</option>
                </select>
            </div>

            <div>
                <label for="chapter" style="margin-bottom: 7px" class="block text-gray-700 dark:text-gray-300 font-medium">Select your Chapter:</label>
                <select id="chapter" required class="w-full border-gray-300 rounded-lg shadow-sm dark:bg-gray-700 dark:border-gray-600 dark:text-white p-2 focus:ring-2 focus:ring-blue-500">
                    <option value="1">Chapter 1</option>
                    <option value="2">Chapter 2</option>
                    <option value="3">Chapter 3</option>
                    <option value="4">Chapter 4</option>
                </select>
            </div>

            <div id="drop-zone" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg text-center cursor-pointer hover:border-blue-500 dark:hover:border-blue-400 transition-all duration-300 p-6">
                <input type="file" id="patchFile" accept=".xdelta" class="hidden" required />
                <img src="upload.png" class="mx-auto h-12 w-12" />
                <p class="mt-4 text-sm text-gray-500 dark:text-gray-400">
                    <span class="font-semibold text-blue-600 dark:text-blue-400">Click to upload</span>
                    or drag & drop
                </p>
                <p class="text-xs text-gray-500 dark:text-gray-500 mt-1">
                    Select your .xdelta patch file!
                </p>
            </div>

            <button type="submit" class="w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg shadow-md transition-colors duration-300 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75">
                Load it up!
            </button>
        </form>

        <pre id="log" class="mt-6 p-4 bg-gray-100 dark:bg-gray-700 rounded-lg h-40 overflow-y-auto text-xs text-gray-700 dark:text-gray-300" hidden></pre>
    </div>

    <script>
        const dropZone = document.getElementById("drop-zone");
        const patchFile = document.getElementById("patchFile");
        const uploadImg = dropZone.querySelector("img");
        const fileNameText = dropZone.querySelector("p:first-of-type");
        const fileHintText = dropZone.querySelector("p.text-xs");

        function updateDropZoneDisplay(file) {
            fileNameText.innerHTML = `<span class="text-lg font-bold text-blue-600 dark:text-blue-400">${file.name}</span>`;
            fileHintText.textContent = ".xdelta patch file selected!";
            uploadImg.src = "good.png";
        }
        dropZone.addEventListener("click", () => patchFile.click());
        dropZone.addEventListener("dragover", (e) => {
            e.preventDefault();
            dropZone.classList.add("drag-over");
        });
        dropZone.addEventListener("dragleave", () =>
            dropZone.classList.remove("drag-over"),
        );
        dropZone.addEventListener("drop", (e) => {
            e.preventDefault();
            dropZone.classList.remove("drag-over");
            if (e.dataTransfer.files.length > 0) {
                patchFile.files = e.dataTransfer.files;
                updateDropZoneDisplay(e.dataTransfer.files[0]);
            }
        });
        patchFile.addEventListener("change", () => {
            if (patchFile.files.length > 0) {
                updateDropZoneDisplay(patchFile.files[0]);
            }
        });
    </script>
    <script>
        async function fileToUint8Array(file, log) {
            log.textContent += `Reading patch file: ${file.name}...\n`;
            const arr = new Uint8Array(await file.arrayBuffer());
            log.textContent += `Patch file done (${arr.length} bytes)\n`;
            return arr;
        }
        async function fetchToUint8Array(url, log, version, chapter) {
            log.textContent += `Fetching chapter ${chapter}, version ${version}: ${url}\n`;
            const res = await fetch(url);
            if (!res.ok) throw new Error(`HTTP ${res.status} fetching ${url}`);
            const arr = new Uint8Array(await res.arrayBuffer());
            log.textContent += `Chapter ${chapter} done (${arr.length} bytes).\n`;
            return arr;
        }
        async function applyPatch(sourceBytes, patchBytes, log) {
            log.textContent += "Starting patcher\n";
            return new Promise((resolve, reject) => {
                const worker = new Worker("xdelta3.worker.js", {
                    type: "module",
                });
                let chunks = [];
                let writer = {
                    write: (chunk) => {
                        chunks.push(chunk);
                        log.textContent += `Wrote ${chunk.byteLength} bytes...\n`;
                    },
                    close: () => {
                        log.textContent += "Patching done.\n";
                        resolve(new Blob(chunks));
                    },
                    abort: (err) => {
                        log.textContent += "Patching aborted: " + err.message + "\n";
                        reject(err || new Error("Aborted"));
                    },
                };
                worker.onmessage = (e) => {
                    if (!e.data) return;
                    const {
                        final,
                        bytes,
                        error,
                        errorMessage,
                        errorCode
                    } = e.data;
                    if (!final) {
                        writer.write(bytes);
                        return;
                    }
                    if (error) {
                        writer.abort(
                            new Error(errorMessage || `Worker error code ${errorCode}`),
                        );
                    } else {
                        writer.close();
                    }
                };
                log.textContent += "Sending files to patcher...\n";
                worker.postMessage({
                    command: "start",
                    sourceFile: new Blob([sourceBytes]),
                    patchFile: new Blob([patchBytes]),
                });
            });
        }
        const origFetch = window.fetch;
        window.fetch = async function(input, init) {
            let url = input;
            if (typeof url === "string") {
                if (url.endsWith("game.unx") && window.gameUnxURL) {
                    url = window.gameUnxURL;
                } else if (url.endsWith("runner.data")) {
                    url = `chapter${window.selectedChapter}/runner.data`;
                } else if (url.endsWith("runner.wasm")) {
                    url = `chapter${window.selectedChapter}/runner.wasm`;
                } else if (url.endsWith("runner.js")) {
                    url = `chapter${window.selectedChapter}/runner.js`;
                }
            } else if (url instanceof Request) {
                const cloned = url.clone();
                let newUrl = cloned.url;
                if (newUrl.endsWith("game.unx") && window.gameUnxURL)
                    newUrl = window.gameUnxURL;
                else if (newUrl.endsWith("runner.data"))
                    newUrl = `chapter${window.selectedChapter}/runner.data`;
                else if (newUrl.endsWith("runner.wasm"))
                    newUrl = `chapter${window.selectedChapter}/runner.wasm`;
                else if (newUrl.endsWith("runner.js"))
                    newUrl = `chapter${window.selectedChapter}/runner.js`;
                url = new Request(newUrl, cloned);
            }
            return origFetch.call(this, url, init);
        };
        const origXHR = XMLHttpRequest.prototype.open;
        XMLHttpRequest.prototype.open = function(
            method,
            url,
            async,
            user,
            password,
        ) {
            if (typeof url === "string") {
                if (url.endsWith("game.unx") && window.gameUnxURL)
                    url = window.gameUnxURL;
                else if (url.endsWith("runner.data"))
                    url = `chapter${window.selectedChapter}/runner.data`;
                else if (url.endsWith("runner.wasm"))
                    url = `chapter${window.selectedChapter}/runner.wasm`;
                else if (url.endsWith("runner.js"))
                    url = `chapter${window.selectedChapter}/runner.js`;
            }
            return origXHR.call(this, method, url, async, user, password);
        };
        document
            .getElementById("patchForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const log = document.getElementById("log");
                log.hidden = false;
                log.textContent = "Starting patch!\n";
                const version = document.getElementById("version").value;
                const chapter = document.getElementById("chapter").value;
                window.selectedChapter = chapter;
                const patchFileInput = document.getElementById("patchFile");
                if (!patchFileInput.files.length) {
                    log.textContent += "No patch file.\n";
                    return;
                }
                const patchFile = patchFileInput.files[0];
                const sourcePath = `unmod/${version}/chap${chapter}.unx`;
                try {
                    const sourceBytes = await fetchToUint8Array(
                        sourcePath,
                        log,
                        version,
                        chapter,
                    );
                    const patchBytes = await fileToUint8Array(patchFile, log);
                    const patchedBlob = await applyPatch(sourceBytes, patchBytes, log);
                    const url = URL.createObjectURL(patchedBlob);
                    window.gameUnxURL = url;
                    log.textContent += "Loading chapter HTML...\n";
                    const res = await fetch(`chapter${chapter}/index.html`);
                    let html = await res.text();
                    html = html.replace(
                        /const gameUnxUrl = 'game\.unx';/,
                        `const gameUnxUrl = '${url}';`,
                    );
                    document.documentElement.innerHTML = html;
                    document.querySelectorAll("script").forEach((oldScript) => {
                        const newScript = document.createElement("script");
                        if (oldScript.src) {
                            if (oldScript.src.endsWith("runner.js")) {
                                newScript.src = `chapter${chapter}/runner.js`;
                            } else {
                                newScript.src = oldScript.src;
                            }
                        } else {
                            newScript.textContent = oldScript.textContent;
                        }
                        document.body.appendChild(newScript);
                    });
                } catch (err) {
                    log.textContent += "Patch failed: " + err.message + "\n";
                }
            });
    </script>
    <script src="verif.js"></script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"version":"2024.11.0","token":"2a95fe4032ac410e9e23ff5c9d15b6fe","r":1,"server_timing":{"name":{"cfCacheStatus":true,"cfEdge":true,"cfExtPri":true,"cfL4":true,"cfOrigin":true,"cfSpeedBrain":true},"location_startswith":null}}' crossorigin="anonymous"></script>
</body>

</html>
